<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>o</title><link>https://omuric.github.io/</link><description>Recent content on o</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sun, 24 Jul 2022 17:00:00 +0900</lastBuildDate><atom:link href="https://omuric.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>ISUCON 12 予選 参加記</title><link>https://omuric.github.io/posts/isucon12-qualify/</link><pubDate>Sun, 24 Jul 2022 17:00:00 +0900</pubDate><guid>https://omuric.github.io/posts/isucon12-qualify/</guid><description>&lt;h1 id="isucon-12-予選-参加記">ISUCON 12 予選 参加記&lt;/h1>
&lt;p>2022年 7月23日 (土) に開催された ISUCON 12 の予選にチームO (dice801, daiju, omu) で Rust で参加しました&lt;br>
自分達の最終結果は 25598 点で、20位で予選突破しました。&lt;br>
(&lt;a href="https://isucon.net/archives/56838276.html">最終結果一覧&lt;/a>)&lt;/p>
&lt;p>&lt;img src="https://omuric.github.io/isucon12-qualify/benchmark.png" alt="">&lt;/p>
&lt;h2 id="事前準備">事前準備&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://omuric.github.io/posts/isucon10-qualify/">ISUCON 10&lt;/a> や ISUCON 11 で使ったツール類を準備
&lt;ul>
&lt;li>&lt;a href="https://github.com/sagiegurari/cargo-make">cargo-make&lt;/a>
&lt;ul>
&lt;li>各操作を定義してデプロイや kataribe, pt-query-digest の実行など、コマンド一発で諸々できるようにしていた&lt;/li>
&lt;li>↓の感じで各操作の通知が discord に来る感じにもしていた&lt;/li>
&lt;li>&lt;img src="https://omuric.github.io/isucon12-qualify/notify.png" alt="">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/omuric/isuconf">isuconf&lt;/a>
&lt;ul>
&lt;li>設定ファイルの管理を行うために自前で用意した CLI ツール&lt;/li>
&lt;li>&lt;img src="https://raw.githubusercontent.com/omuric/isuconf/main/.img/screenshot.png" alt="">&lt;/li>
&lt;li>各インスタンスの設定ファイルの収集・配布を簡単に出来るやつ&lt;/li>
&lt;li>去年の予選時にこしらえたもので、今年も幾つか機能追加をした (push, pull 操作の並列化や ssh-config 生成のサポートなど)&lt;/li>
&lt;li>我ながらそこそこ便利で、去年のチームメンバが別のチームでも布教してくれていて嬉しかったです&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="sqlx">https://github.com/launchbadge/sqlx&lt;/a> での典型的な DB 操作の素振り
&lt;ul>
&lt;li>普段使わないので本番でハマりがちという反省から&lt;/li>
&lt;li>in 句による select や bulk insert などの典型と思われるものを練習した&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="hinohi/rust-opentelemetry-auto-span">https://github.com/hinohi/rust-opentelemetry-auto-span&lt;/a>
&lt;ul>
&lt;li>チームメンバの daiju さんが作った sqlx, reqwest の opentelemetry スパン挿入を簡単にするやつ&lt;/li>
&lt;li>関数にアノテーションをつけるだけでボトルネックが見えるようになり最高でした&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="チームでやったこと">チームでやったこと&lt;/h2>
&lt;ul>
&lt;li>N+1 クエリの解消&lt;/li>
&lt;li>sqlite から mysql への移行&lt;/li>
&lt;li>アプリケーションサーバと DB サーバの分離&lt;/li>
&lt;li>テーブルの圧縮
&lt;ul>
&lt;li>visit_history&lt;/li>
&lt;li>player_score&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>TBW&lt;/p>
&lt;h2 id="当日自分がやったこと">当日自分がやったこと&lt;/h2>
&lt;ul>
&lt;li>N+1 クエリの解消
&lt;ul>
&lt;li>コミットログ見ると4つぐらい直したみたいです
&lt;ul>
&lt;li>competition_ranking_handler の N+1 を修正&lt;/li>
&lt;li>player_handler の N+1 を解消&lt;/li>
&lt;li>player_score を bulk insert&lt;/li>
&lt;li>competition_score_handler の N+1 を修正&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>player_score 圧縮のアプリ側の対応
&lt;ul>
&lt;li>row_num が一番大きいものだけを残せばいいのでそうする&lt;/li>
&lt;li>初期データの修正は daiju さんが sqlite -&amp;gt; mysql への切替時に合わせてやってくれていました&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>sqlite -&amp;gt; mysql への切り替えのアプリ側の対応
&lt;ul>
&lt;li>コード中の sqlite への接続箇所を mysql に切り替える対応&lt;/li>
&lt;li>データ構造の設計や切り替えは daiju さんが全てやってくれていました&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>dispense_id の生成処理修正
&lt;ul>
&lt;li>アプリ側で UUID を生成する形に変更&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>pem ファイルをプログラム起動時に読み込む
&lt;ul>
&lt;li>リクエスト毎にファイル読み込みをしていたので修正&lt;/li>
&lt;li>コードリーディング時にパッと目についたので直したけど余り意味なかったかも&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="良かったこと">良かったこと&lt;/h2>
&lt;ul>
&lt;li>Rust での参加
&lt;ul>
&lt;li>Rust で出るのは三回目ですが、ORM 周り (というか sqlx) ぐらいでしかバグは出ず改めて良い言語だなという感想&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ツール類による効率化
&lt;ul>
&lt;li>ツールによる自動化で主要な操作はコマンド一発で対応できていて体験が良かった&lt;/li>
&lt;li>本質的な改善活動に集中出来た&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="反省点">反省点&lt;/h2>
&lt;ul>
&lt;li>アプリサーバの分離が間に合わなかった
&lt;ul>
&lt;li>最終的な構成はアプリサーバ1台 DBサーバ1台で、1台サーバを余らせている状態だった&lt;/li>
&lt;li>アプリの CPU がきつそうだったので、アプリサーバを2台にしたかったが、flock の引き剥がしが間に合わず対応できなかった&lt;/li>
&lt;li>複数のアプリの状態管理に対する素振りが足りていなかったかなという反省&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>方針決めにあまり貢献できなかったこと
&lt;ul>
&lt;li>大きな変更 (sqlite の mysql への切り替え) の方針については主に daiju さん, dice801 さんが会話して方針を決めていた&lt;/li>
&lt;li>自分は決まった方針に対して必要な一部タスクを実施する人になっており、方針決めに頭を使えなかったのは反省&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="感想">感想&lt;/h2>
&lt;p>今年で ISUCON に参加するのは 5年目ですが、ようやく初めて予選突破できました。&lt;br>
優秀なチームメンバと良いチームワークで問題に取り組めたのが良かったのかなと思います。&lt;br>
本戦でもチームに貢献して良い成績を取れるよう頑張りたいです。&lt;/p></description></item><item><title>ICFP-PC 2021 参加記</title><link>https://omuric.github.io/posts/icfp-pc2021/</link><pubDate>Sat, 24 Jul 2021 20:55:00 +0900</pubDate><guid>https://omuric.github.io/posts/icfp-pc2021/</guid><description>&lt;h1 id="icfp-pc-2021-参加記">ICFP-PC 2021 参加記&lt;/h1>
&lt;p>2021年 7/9(金) ~ 7/12(月) に開催された ICFP-PC 2021 にチーム chirijako で参加しました&lt;br>
コンテストサイト&lt;br>
&lt;a href="https://icfpcontest2021.github.io/index.html">https://icfpcontest2021.github.io/index.html&lt;/a>&lt;br>
リポジトリ (諸々認証情報は無効化済み)&lt;br>
&lt;a href="https://gitlab.com/icfp-pc2021_e-seikatsu/icfp-pc2021">https://gitlab.com/icfp-pc2021_e-seikatsu/icfp-pc2021&lt;/a>&lt;/p>
&lt;p>ちょこちょこメンバーが変わりつつ、このチームで参加するのは今年で五年目ぐらい&lt;br>
(去年は諸事情により自分は参加しなかった)&lt;br>
今年は Rust で参加しました&lt;br>
例年 C++、Python で参加してましたが、今年は何故かメンバー全員 Rust 使えるようになっており凄い&lt;/p>
&lt;h2 id="結果">結果&lt;/h2>
&lt;p>6/160 位でした&lt;br>
いつもは 30 位くらいなのでかなり健闘できた (嬉しい)&lt;/p>
&lt;p>&lt;img src="https://omuric.github.io/icfpc2021/result.png" alt="">&lt;/p>
&lt;h2 id="チームでやったこと">チームでやったこと&lt;/h2>
&lt;h3 id="焼きなましソルバ">焼きなましソルバ&lt;/h3>
&lt;ul>
&lt;li>Rust でチームメイトが実装&lt;/li>
&lt;li>クソつよ EC2 インスタンス (c5.24xlarge) 借りて並列でソルバーを回した結果、ほとんどの問題をいい感じに解いた&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://omuric.github.io/icfpc2021/ec2.png" alt="">&lt;/p>
&lt;h3 id="web-ダッシュボード">Web ダッシュボード&lt;/h3>
&lt;ul>
&lt;li>TypeScript + React でチームメイトが実装&lt;/li>
&lt;li>これまで出した解の一覧が問題ごとにランキング形式で見れる&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://omuric.github.io/icfpc2021/web-dashboard-1.jpeg" alt="">&lt;/p>
&lt;ul>
&lt;li>簡易的な操作機構がついており、後述するビジュアライザが出来るまでは、コレで手動で解いていた&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://omuric.github.io/icfpc2021/web-dashboard-2.jpeg" alt="">&lt;/p>
&lt;h3 id="ビジュアライザ">ビジュアライザ&lt;/h3>
&lt;ul>
&lt;li>Rust で自分が実装&lt;/li>
&lt;li>ソルバーで解けない問題はコレを使って手動で解いた&lt;/li>
&lt;li>詳細は後述&lt;/li>
&lt;/ul>
&lt;h2 id="自分がやったこと">自分がやったこと&lt;/h2>
&lt;p>例年ソルバー係をやっていましたが、今年は途中で無力を感じてビジュアライザ係になりました&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gitlab.com/icfp-pc2021_e-seikatsu/icfp-pc2021/-/tree/main/pad">https://gitlab.com/icfp-pc2021_e-seikatsu/icfp-pc2021/-/tree/main/pad&lt;/a>&lt;/li>
&lt;li>使ったことが無い &lt;a href="https://github.com/hecrj/coffee">coffee&lt;/a> をノリで使ってみたがかなり良かった&lt;/li>
&lt;li>ビジュアライザ上で焼きなましを実行できるようにしてみた
&lt;ul>
&lt;li>「人間が大まかな形を作る」 -&amp;gt; 「焼きなましで微調整」がかなり体験として良かった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://omuric.github.io/icfpc2021/poses-pad.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://omuric.github.io/icfpc2021/poses-pad.gif" alt="">&lt;/p>
&lt;p>&lt;img src="https://omuric.github.io/icfpc2021/poses-ope.png" alt="">&lt;/p>
&lt;p>チームメンバーの意見を参考にしつつ色々追加していった結果、↑の通りかなり多機能になった&lt;br>
「実装」 -&amp;gt; 「メンバーからのフィードバック」 -&amp;gt; 「実装」 のサイクルができていて、開発楽し〜〜となっていた&lt;/p>
&lt;h2 id="ビジュアライザについて振り返ってみて感じたことなど">ビジュアライザについて振り返ってみて感じたことなど&lt;/h2>
&lt;h3 id="ソルバーとの結合は重要">ソルバーとの結合は重要&lt;/h3>
&lt;ul>
&lt;li>ソルバーの挙動確認やデバッグの効率が上がる&lt;/li>
&lt;li>ビジュアライザとソルバーを結合することで、手動解も作りやすくなる&lt;/li>
&lt;li>できれば実装を始める前にソルバー係とインタフェースの打ち合わせをしたほうが良い&lt;/li>
&lt;/ul>
&lt;h3 id="手動で解くのが有効かどうかで実装方針が変わる">手動で解くのが有効かどうかで実装方針が変わる&lt;/h3>
&lt;p>手動で解くのが有効化どうかは、以下の点が重要&lt;/p>
&lt;ul>
&lt;li>ソルバーの実装が難しい&lt;/li>
&lt;li>盤面が人間の脳に理解しやすい
&lt;ul>
&lt;li>二次元の問題&lt;/li>
&lt;li>操作順がスコアリングに影響しない問題
&lt;ul>
&lt;li>順番を気にするのは人間には難しい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>手動で解いてくれそうなメンバーが居る
&lt;ul>
&lt;li>手動で解く人が居ない場合、手動で解くことは有効でない&lt;/li>
&lt;li>多ければ多いほど手動で解くことは有効&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>手動が有効でないならソルバーの挙動確認がビジュアライザの主目的になるので、実装方針に影響する&lt;br>
一部の問題のみ↑が当てはまるのはありがちなストーリーなので、問題の把握は大事&lt;/p>
&lt;h3 id="web-で実装するかネイティブで実装するか">web で実装するか、ネイティブで実装するか&lt;/h3>
&lt;p>結構悩みどころで、比較してみると&lt;/p>
&lt;ul>
&lt;li>ネイティブアプリ
&lt;ul>
&lt;li>環境依存の挙動が比較的出やすい&lt;/li>
&lt;li>ソルバーをビジュアライザと結合しやすい
&lt;ul>
&lt;li>言語が同じなら結合コストがかなり小さくなる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>入出力はコマンドライン上の指定が可能で楽&lt;/li>
&lt;li>自由に言語選択できる&lt;/li>
&lt;li>言語に対する習熟度によっては実行までのコストが大きい
&lt;ul>
&lt;li>バイナリを配布できるなら大丈夫&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Web アプリ
&lt;ul>
&lt;li>環境依存の挙動が少ない&lt;/li>
&lt;li>ソルバーとの結合が難しい
&lt;ul>
&lt;li>ウェブアセンブリ使えばまあ出来る?&lt;/li>
&lt;li>少なくともネイティブアプリよりはコストがかかるはず&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>入出力ファイルのインターフェースが (普通に実装すると) 扱いづらい&lt;/li>
&lt;li>(基本的には) 言語を typescript に強制される&lt;/li>
&lt;li>どこかにホスティングすれば実行までのコストは無&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>上記踏まえて、ソルバーとの結合が結構重要なので、ソルバー係と言語を合わせてネイティブアプリが良さそうかもと思った&lt;br>
ウェブアセンブリに習熟すれば話が変わるのかも&lt;/p>
&lt;h2 id="来年に向けてやっとくこと">来年に向けてやっとくこと&lt;/h2>
&lt;h3 id="ソルバー周り">ソルバー周り&lt;/h3>
&lt;ul>
&lt;li>いい感じのソルバーを実装できなかったのは反省&lt;/li>
&lt;li>焼きなましを AHC の過去問とかで素振りする&lt;/li>
&lt;/ul>
&lt;h3 id="ビジュアライザ周り">ビジュアライザ周り&lt;/h3>
&lt;ul>
&lt;li>三次元の何かのビジュアライザを実装してみる&lt;/li>
&lt;li>今回の実装から二次元ビジュアライザのテンプレを作る&lt;/li>
&lt;li>ウェブアセンブリの素振り&lt;/li>
&lt;/ul>
&lt;h3 id="幾何">幾何&lt;/h3>
&lt;ul>
&lt;li>自前実装が結構しんどいのでいい感じの幾何ライブラリを探す&lt;/li>
&lt;/ul></description></item><item><title>Codingame Fall Challenge 2020 参加記</title><link>https://omuric.github.io/posts/codingame-fall-challenge-2020/</link><pubDate>Tue, 24 Nov 2020 00:40:00 +0900</pubDate><guid>https://omuric.github.io/posts/codingame-fall-challenge-2020/</guid><description>&lt;h1 id="codingame-fall-challenge-2020-参加記">Codingame Fall Challenge 2020 参加記&lt;/h1>
&lt;p>2020年 11/12(木) ~ 11/23(月) に開催された &lt;a href="https://www.codingame.com/contests/fall-challenge-2020">Codingame Fall Challenge 2020&lt;/a> に参加しました&lt;br>
最終結果は 41/7043 位でした&lt;/p>
&lt;p>&lt;img src="https://omuric.github.io/codingame-fall-challenge-2020/result.png" alt="">&lt;/p>
&lt;h2 id="やったこと">やったこと&lt;/h2>
&lt;h3 id="ビームサーチ">ビームサーチ&lt;/h3>
&lt;ul>
&lt;li>幅1 で時間制限まで回す&lt;/li>
&lt;li>深さは max(20, 35 - turn)
&lt;ul>
&lt;li>浅い読みだと LEARN の価値が低く見積もられると想定して深くした&lt;/li>
&lt;li>35 ターンでゲームが終了するとざっくり想定&lt;/li>
&lt;li>20 は最低読む深さで調整の結果だが長過ぎる気もする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>12 ターン以降は LEARN を遷移から外す
&lt;ul>
&lt;li>リプレイを見る限り後半 LEARN を必要としない場面が多いため探索効率を優先&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>相手が常に一番下を LEARN すると想定して適宜 LEARN を遷移から外す
&lt;ul>
&lt;li>あとで取れば良いと判断して一旦取らないでおくような操作を弾く&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="評価関数">評価関数&lt;/h3>
&lt;p>「BREW でスコアに変換される素材」と「ゲーム終了後まで残る素材」で価値が異なる為、&lt;br>
現在累計で何回 BREW を行ったかでどちらに属する素材なのかざっくり判定することにした&lt;/p>
&lt;ul>
&lt;li>5 回目の BREW をまだ行っていなければ現在のインベントリを 「BREW でスコアに変換される素材」と判定
&lt;ul>
&lt;li>評価値は &lt;code>score + (tier-0 + tier-1 * 2 + tier-2 * 3 + tier-3 * 4)&lt;/code>&lt;/li>
&lt;li>実際には終了後まで残る素材もあるが判定できないので無視&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>5 回目の BREW を行っていれば「ゲーム終了後まで残る素材」と判定
&lt;ul>
&lt;li>評価値は &lt;code>score + (tier-1 + tier-2 + tier-3)&lt;/code>&lt;/li>
&lt;li>実際にはこの中から一部が 「BREW でスコアに変換される素材」になるが判定できないので無視&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>上記の評価関数だと LEARN を行うことの価値が低く見積もられてしまい、&lt;br>
LEARN せずに CAST する操作が優先的に探索されてしまう。&lt;br>
LEARN してから CAST する操作を優先的に探索する為に以下の補正を加えた&lt;/p>
&lt;ul>
&lt;li>15 ターン目までは習得済み CAST の個数を補正値として評価値に加える&lt;/li>
&lt;li>15 ターン目以降は補正を外す
&lt;ul>
&lt;li>15 ターン辺りからは LEARN してから CAST する操作のほうが素で評価値が高くなるだろうと想定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>またゲーム終了となる操作列の場合は厳密なスコア計算を行い&lt;/p>
&lt;ul>
&lt;li>相手より自分のスコアが高い場合は評価値を &lt;code>+INF - turn * N + score&lt;/code>&lt;/li>
&lt;li>自分より相手のスコアが高い場合は評価値を &lt;code>-INF - turn * N + score&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>とした (N は取りうる score より十分に大きい値)&lt;br>
できるだけ早くゲームを終わらせて、その上でスコアが高い状態を探すイメージ&lt;/p>
&lt;h3 id="相手側の探索">相手側の探索&lt;/h3>
&lt;p>相手の行動により自分の将来の行動が制限される場合がある&lt;br>
これにより発生する不利をできるだけ無くすために、相手側から見た状態でビームサーチをして、&lt;br>
その探索結果に基づき自分の探索を行うことにした&lt;br>
探索で得られた N ターン先までの相手の状態をターン毎に持っておき、自分の探索を行う際に以下のような処理を行った&lt;/p>
&lt;ul>
&lt;li>相手が使用した BREW は遷移から外す&lt;/li>
&lt;li>相手が使用した BREW を自分が使用していた場合は妨害が成功したとみなして評価値を少し良くする&lt;/li>
&lt;li>相手がゲームを終了させた場合はこちらもゲーム終了とみなす&lt;/li>
&lt;/ul>
&lt;p>N ターン目の自分の状態を評価する場合は N ターン目の相手の状態を参照する&lt;br>
ゲーム終了とみなした状態はそれ以上探索しない&lt;br>
探索で得られた結果とは異なる操作を行われた場合のことを考えるとあまり良い手ではなかったかも&lt;/p>
&lt;h3 id="重複盤面の排除">重複盤面の排除&lt;/h3>
&lt;p>ビームサーチの探索の中で同一の状態を複数回探索してしまうのを防ぐために、以下のような形で重複盤面の排除を行った&lt;/p>
&lt;p>以下の値で同一な状態かを判定する&lt;/p>
&lt;ul>
&lt;li>操作集合
&lt;ul>
&lt;li>同一である場合、例外を除いて同一な状態になる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用済みの CAST
&lt;ul>
&lt;li>操作集合が同一でも REST のタイミングによって変化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>インベントリの tier-0
&lt;ul>
&lt;li>操作集合が同一でも LEARN のタイミングによって変化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>スコア
&lt;ul>
&lt;li>操作集合が同一でも BREW のタイミングによって変化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>スコアが低いものは探索する必要がないと判断し、以下の key, value でメモ化した&lt;/p>
&lt;ul>
&lt;li>key: &lt;code>(操作集合, 使用済みの CAST, インベントリの tie-0)&lt;/code>&lt;/li>
&lt;li>value: &lt;code>スコア&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>同一の key がメモに存在し、&lt;code>メモのスコア &amp;gt;= スコア&lt;/code> であればその状態はそれ以上探索しないようにした&lt;br>
操作集合については各操作をハッシュ値に変換して足し合わせたものを用意することで計算が重くならないようにした&lt;br>
(遷移のたびに操作に対応したハッシュ値を足して更新する)&lt;/p>
&lt;p>操作順序による無駄な探索を減らすために導入したが、
操作集合が異なるが同一の状態という場合に対応できないので改善の余地がありそう&lt;/p>
&lt;h3 id="高速化">高速化&lt;/h3>
&lt;p>使用済み CAST, 取得済み LEARN などの集合を BitSet で管理するようにした&lt;br>
(事前に ID を圧縮しておくことで 32bit の整数値に十分収まる)&lt;br>
また BREW のボーナス計算や LEARN の先読み税計算のためのカウンタも BREW、LEARN それぞれ一つの整数値に収まるようにした&lt;br>
(愚直にやると BREW では 2つ LEARN では 6つのカウンタが必要になる)&lt;/p>
&lt;h2 id="やったけどだめだったこと">やったけどだめだったこと&lt;/h2>
&lt;h3 id="並列化">並列化&lt;/h3>
&lt;p>コンテスト中 twitter で Codingame は並列化可能っぽい？というのを見かけたので mpsc を使いビームサーチの並列化を試したが、 実際に動かした際に探索回数が並列化前よりむしろ悪化した為、Codingame の実行環境ではマルチスレッドが使用できないと判断し、あまり調査せずそこで切り上げてしまった&lt;br>
(もしかしたらできるのかも)&lt;/p>
&lt;h3 id="learn-の価値推定">LEARN の価値推定&lt;/h3>
&lt;p>LEARN の取得がその後どの程度スコアに貢献するのか推定できれば min_max 法でいい感じにできる気がしたので&lt;br>
LEARN の価値推定を試したがうまくいかず&lt;/p>
&lt;p>以下が CAST が貢献する 1 ゲーム当たりの平均スコアになるだろうと想定&lt;/p>
&lt;p>&lt;code>(CAST した回数) / (LEARN した回数) x (CAST により加算されるインベントリの価値)&lt;/code>&lt;/p>
&lt;p>ローカル環境で自己対戦を回して上記を記録し&lt;br>
それを調整しつつ評価値として用いてみたが、あまり芳しくなかったので切り上げた&lt;/p>
&lt;h2 id="本質とは関係ないこと">本質とは関係ないこと&lt;/h2>
&lt;h3 id="ローカルでの実行環境の構築">ローカルでの実行環境の構築&lt;/h3>
&lt;p>&lt;a href="https://github.com/CodinGame/FallChallenge2020">テスターのリポジトリ&lt;/a> が公開されているので、若干コードをいじりつつ手元でビルドしてローカル実行できるようにした&lt;br>
これは主にベンチマーク用の入力ファイルを生成するときに役立った&lt;br>
全然関係ないけど &lt;a href="https://github.com/CodinGame/FallChallenge2020/issues/2">issue&lt;/a> を立ててる人がいたのでコメント返したら解決したっぽくて良かった&lt;/p>
&lt;h3 id="ci">CI&lt;/h3>
&lt;p>元々マラソン用に Github + AWS CodeBuild の構成を用意しており手元のコードを push すると CI が動いて&lt;br>
slack に通知が行く感じになっていた&lt;br>
あまり活用できてる感じは無かったが、一応少し書いたテストが毎回実行されてるので良かった気はする&lt;/p>
&lt;h3 id="rust">Rust&lt;/h3>
&lt;p>Clion でデバッグ機能使っても C++ 無限にバグらせる自分が、&lt;br>
Rust だとほぼバグなく実装に専念できたので、マジで良い言語だと思います&lt;br>
最近はコンパイル通すのも苦でなくなった感がある&lt;/p>
&lt;h2 id="感想">感想&lt;/h2>
&lt;p>学生時代ぶりに長期間の AI コンテストに参加しました&lt;br>
あの頃と比べてアルゴリズム的な能力は全く成長してないですが、それ以外の部分が多少なりとも社会で鍛えられたのでそれなりに良い結果が出せた気がします&lt;br>
あと今は無職なのでフルで参加でき、時間を使いきれたのも大きいです&lt;br>
社会で生活をしながらこういう長期コンテストに参加して結果を出せる方は本当に尊敬の気持ちです&lt;/p>
&lt;h2 id="おまけ-危なかった話">[おまけ] 危なかった話&lt;/h2>
&lt;p>ビームサーチで状態同士の価値を比較する必要があり、以下のようなコードを書いていました&lt;br>
これは &lt;code>self.value&lt;/code> と &lt;code>other.value&lt;/code> を比較し、比較に失敗した場合 (値が NaN だった等) に except 内をエラー出力としてプログラムが落ちる感じです&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span> Ord &lt;span style="color:#66d9ef">for&lt;/span> StateWrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> S: Clone,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self, other: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Self&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Ordering&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.value.partial_cmp(&lt;span style="color:#f92672">&amp;amp;&lt;/span>other.value).expect(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> format!(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Failed compare f64 (value0={}, value1={})&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> other.value, self.value,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .as_str(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>自分としては比較に失敗した場合のみエラー用の文字列が生成されてほしい気持ちだったんですが、&lt;br>
上記だと常に文字列が生成されるコードになっています&lt;br>
そのためビームサーチ内の状態比較のたびに上記のエラー文の生成が走りパフォーマンスが劇的に低下していました&lt;br>
最終的に以下に修正して事なきを得ました&lt;br>
以下のコードでは比較失敗時のみエラー文の生成が行われます&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span> Ord &lt;span style="color:#66d9ef">for&lt;/span> StateWrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> S: Clone,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self, other: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Self&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Ordering&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.value.partial_cmp(&lt;span style="color:#f92672">&amp;amp;&lt;/span>other.value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .unwrap_or_else(&lt;span style="color:#f92672">||&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic!(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Failed compare f64 (value0={}, value1={})&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.value, other.value,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/rust-lang/rust-clippy">rust-clippy&lt;/a> という rust の静的解析ツールがあり、 Legend に上がった後になんとなくかけてみたんですが、指摘事項を修正した後にベンチマークを取ると異様に速度が向上しており糞ビックリという話でした&lt;br>
clippy ありがとう&lt;/p></description></item><item><title>ISUCON 10 予選 参加記</title><link>https://omuric.github.io/posts/isucon10-qualify/</link><pubDate>Mon, 14 Sep 2020 16:33:29 +0900</pubDate><guid>https://omuric.github.io/posts/isucon10-qualify/</guid><description>&lt;h1 id="isucon-10-予選-参加記">ISUCON 10 予選 参加記&lt;/h1>
&lt;p>2020年 9月12日 (土) に開催された ISUCON 10 の予選に一人チームで Rust で参加しました&lt;br>
予選突破のボーダーが 2158 点で、自分の最終結果は 1017 点でした&lt;br>
(&lt;a href="http://isucon.net/archives/55008744.html">最終結果一覧&lt;/a>)&lt;/p>
&lt;h2 id="事前準備">事前準備&lt;/h2>
&lt;ul>
&lt;li>ISUCON 9 の参照実装を Rust で書き直す (未完)
&lt;ul>
&lt;li>actix-web + sqlx で実装&lt;/li>
&lt;li>半分ぐらい実装して、ライブラリは理解した気持ちになったのと実装がしんどくなったので諦めた&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/tohutohu/isucon9/blob/master/Makefile">ISUCON 9 の予選1日目一位の方の Makefile&lt;/a> をパクる
&lt;ul>
&lt;li>Makefile 使うのが辛かったので &lt;a href="https://github.com/sagiegurari/cargo-make">cargo-make&lt;/a> で書き直した&lt;/li>
&lt;li>オリジナルはサーバ内で使う想定になっているが、全サーバを一度に操作したかったのでローカルから各サーバに ssh して操作する形に書き直した&lt;/li>
&lt;li>自分の運用に合わせて幾つかコマンドを追加&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>設定ファイルの管理
&lt;ul>
&lt;li>各サーバの設定ファイル (hosts, my.cnf, nginx.conf, sysctl.cnf) をローカルで git 管理するように&lt;/li>
&lt;li>nginx.conf と my.cnf はデプロイ前にバリデーションをかけるようにした&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>sysctl, mysql, nginx のいい感じの設定を調べる&lt;/li>
&lt;li>nginx でのロードバランシング、mysql のレプリケーションを素振り&lt;/li>
&lt;/ul>
&lt;h2 id="当日やったこと">当日やったこと&lt;/h2>
&lt;ul>
&lt;li>sysctl, mysql, nginx に設定ファイルにいい感じの設定を入れる&lt;/li>
&lt;li>スロークエリを確認しながら index を貼る&lt;/li>
&lt;li>nazotte の内包判定をアプリケーション側で行う
&lt;ul>
&lt;li>判定のために SQL クエリの発行が行われていたので修正&lt;/li>
&lt;li>競プロっぽいなと思いつつ &lt;a href="https://www.nttpc.co.jp/technology/number_algorithm.html">NTTPC さんの記事&lt;/a> を写経した&lt;/li>
&lt;li>絶対バグらせる気がしたが、オリジナルとAPI のレスポンスを比べて diff がなかったので恐らくバグってないはず (1ケースしか試してないけど&amp;hellip;) (ベンチも通ってるので多分大丈夫)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>物件のレコメンドのクエリを修正
&lt;ul>
&lt;li>ドアサイズを絞るために無駄な OR があったので消した
&lt;ul>
&lt;li>width, height の大きい方を door_size_0, 小さい方を door_size_1 としてカラムを追加&lt;/li>
&lt;li>椅子の w, h, z の一番小さいものを door_size_1 と比較, 二番目に小さいものを door_size_0 と比較する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>結局いい感じに index に乗らなかった (SQL の知識が足らずここで諦めてしまった)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Bot を nginx で弾く
&lt;ul>
&lt;li>ドキュメント記載の Bot の正規表現は PHP preg_match() に準拠してそうだった (勘) ので、&lt;a href="http://okumocchi.jp/php/re.php">php 正規表現チェッカー&lt;/a> で確認しながらテストした&lt;/li>
&lt;li>nginx の if で使える正規表現の理解が足りず、弾くとまずいものまで弾きそうだったので、幾つかのパターンは無視した&lt;/li>
&lt;li>actix-web の Guard を一瞬使おうとしたが正規表現に対応して無かったので諦めた&lt;/li>
&lt;li>スコアに影響するパス ( /api/chair/buy/{id} , /api/estate/req_doc/{id}) は Bot でも通すようにした&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>サーバ構成の変更
&lt;ul>
&lt;li>mysql の CPU 使用率が 90 % ぐらいで張り付いていたので、DB の分割を試したが上手く行かず
&lt;ul>
&lt;li>Write 1 台, Read 2台でレプリケーションを試したが、遅延のためかベンチマークが通らず&amp;hellip; (時間が足らずちゃんと確認できてないので別原因かも)&lt;/li>
&lt;li>アプリケーションの修正も含めてかなり無駄に時間を使ってしまった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>仕方ないので以下の構成で妥協した
&lt;ul>
&lt;li>1: nginx + app&lt;/li>
&lt;li>2: app&lt;/li>
&lt;li>3: mysql&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>テーブル毎に DB 分割思いつきたかった&amp;hellip; (悲しい)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>再起動試験
&lt;ul>
&lt;li>不要なサービスの自動起動を無効にして、全台再起動後にテスト&lt;/li>
&lt;li>コンテスト終了後の再テストで出たスコアが最終結果になると勘違いしており、ここで下振れたスコアのまま放置してしまった&lt;br>
(もともと 1240 点ぐらいで -200 点ぐらい下振れてて悲しかったが、結局予選通ってないのでまあ)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="良かったこと">良かったこと&lt;/h2>
&lt;ul>
&lt;li>Rust で参加
&lt;ul>
&lt;li>これまで Python で参加していたが、あまり書かないので読むのも書くのも脳死でできず辛かった&lt;/li>
&lt;li>最近割と Rust を書く機会が多く、割と習熟できていたのでアプリケーション周りで詰まることは無く良かった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>事前に用意した Makefile
&lt;ul>
&lt;li>ほぼ必要な操作を網羅していて、それらが脳死でできるのでかなり楽だった&lt;/li>
&lt;li>kataribe と pt-query-digest スゴイ&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一人参加
&lt;ul>
&lt;li>必然的にすべての部分を見ないと行けないので、自分に足りない部分が明確になってよかった&lt;/li>
&lt;li>コミュニケーションコストが無なのでそこはかなり楽だった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="反省点">反省点&lt;/h2>
&lt;ul>
&lt;li>SQL 周りの知識不足
&lt;ul>
&lt;li>スロークエリを直す作業で、なかなか index に乗ってくれず辛かった&lt;/li>
&lt;li>作業時間的にもここがボトルネックになっていた&lt;/li>
&lt;li>データベーススペシャリスト試験受けるか&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>インフラ周りの設定の知識不足
&lt;ul>
&lt;li>パラメータが与える影響の理解が不足していて、問題に応じた調整が全然できなかった&lt;/li>
&lt;li>過去問で練習したい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Rust のパフォーマンス測定
&lt;ul>
&lt;li>いい感じに測定する方法がわからず今回は諦めてしまった&lt;/li>
&lt;li>直前に &lt;a href="https://github.com/tikv/pprof-rs">pprof-rs&lt;/a> を試したが、使いこなせる自信が無かったので本番では使わなかった&lt;/li>
&lt;li>NewRelic APM, Rust にも対応してくれ〜〜&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>設定ファイルの管理
&lt;ul>
&lt;li>etckeeper というのがあるらしいので今度使ってみる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>アプリケーションの並列処理
&lt;ul>
&lt;li>今回使わなかったが、もっとラフに入れていっても良かった気がする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="感想">感想&lt;/h2>
&lt;p>予選突破できず悔しかったですが、ドチャクソ楽しかったです&lt;br>
誘う人いないので来年も一人枠を残してほしい&amp;hellip;&lt;/p></description></item></channel></rss>